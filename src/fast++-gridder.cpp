#include "fast++.hpp"
#include <phypp/utility/thread.hpp>

void gridder_t::cache_manager_t::write_model(const model_t& model) {
    if (!cache_file.is_open()) return;

    // TODO: Consider doing this in a worker thread if it slows down execution
    cache_file.write(reinterpret_cast<const char*>(&model.mass), sizeof(model.mass));
    cache_file.write(reinterpret_cast<const char*>(&model.sfr), sizeof(model.sfr));
    cache_file.write(reinterpret_cast<const char*>(model.flux.data.data()),
        model.flux.size()*sizeof(model.flux[0])
    );

    if (!cache_file) {
        warning("could not write to cache file anymore");
        warning("in case you ran out of disk space, the cache file has been removed");
        cache_file.close();
        file::remove(cache_filename);
    }
}

bool gridder_t::cache_manager_t::read_model(model_t& model) {
    if (!cache_file.is_open()) return false;

    cache_file.read(reinterpret_cast<char*>(&model.mass), sizeof(model.mass));
    cache_file.read(reinterpret_cast<char*>(&model.sfr), sizeof(model.sfr));
    cache_file.read(reinterpret_cast<char*>(model.flux.data.data()),
        model.flux.size()*sizeof(model.flux[0])
    );

    if (!cache_file) {
        cache_file.close();
        return false;
    }

    return true;
}

gridder_t::gridder_t(const options_t& opt, const input_state_t& inp, output_state_t& out) :
    opts(opt), input(inp), output(out) {

    // First build a new array from the provided parameters
    if (opts.z_step == 0.0 || abs(opts.z_max - opts.z_min) < opts.z_step) {
        // A single redshift
        output.z = {opts.z_min};
    } else {
        if (opts.z_step_type == 0) {
            // "dz = cte" grid
            output.z = rgen_step(opts.z_min, opts.z_max, opts.z_step);
        } else {
            // "dz ~ (1+z)" grid
            output.z = e10(rgen_step(
                log10(1.0 + opts.z_min), log10(1.0 + opts.z_max), opts.z_step
            )) - 1.0;
        }
    }

    // Now compare this against the grid generated by the zspec/zphot provided by the user
    // In other words, if we have more galaxies to fit than the size of the above grid,
    // we use the individual zspec/zphot as the grid.

    // First compile valid zphot & zspecs
    vec1f cz = input.zspec;

    if (!input.zphot.empty()) {
        vec1u idzp = where(!is_finite(cz));
        cz[idzp] = input.zphot[idzp];
    }

    // ... and only keep valid and unique values
    cz = cz[where(is_finite(cz))];
    cz = unique_values(cz, sort(cz));

    if (output.z.size() < cz.size()) {
        output.z = cz;
    }

    // Grid the rest of the parameter space
    output.metal = opts.metal;
    output.tau   = rgen_step(opts.log_tau_min, opts.log_tau_max, opts.log_tau_step);
    output.age   = rgen_step(opts.log_age_min, opts.log_age_max, opts.log_age_step);
    output.av    = rgen_step(opts.a_v_min,     opts.a_v_max,     opts.a_v_step);
    output.chi2.resize(
        output.metal.size(), output.tau.size(), output.age.size(), output.av.size(), output.z.size()
    );

    if (opts.verbose) {
        note("fitting a grid of ", output.chi2.size(),
            " templates (nz=", output.z.size(), ",ntau=", output.tau.size(),
            ",nage=", output.age.size(), ",nmetal=", output.metal.size(),
            ",nav=", output.av.size(), ")");
    }

    // Base library properties
    cache.cache_filename = opts.output_dir+opts.library+"_"+opts.resolution+"_"+opts.imf+
        "_"+opts.sfh+"_"+opts.dust_law+"_";
    // Grid parameters
    cache.cache_filename += hash(output.z, output.metal, output.av, output.age, output.tau,
        input.lambda, opts.dust_noll_eb, opts.dust_noll_delta, opts.cosmo.H0, opts.cosmo.wm,
        opts.cosmo.wL)+".grid";

    if (opts.verbose) {
        note("cache file ", cache.cache_filename);
    }

    // Open grid file
    cache.cache_file.open(cache.cache_filename, std::ios::binary | std::ios::in | std::ios::out);
    if (!cache.cache_file.is_open()) {
        warning("cache file could not be created");
        warning("the program will not use the cache");
        read_from_cache = false;
    } else {
        cache.cache_file.seekg(0, std::ios_base::end);
        uint_t size = cache.cache_file.tellg();
        uint_t size_expected = output.chi2.size()*input.lambda.size();

        if (size == 0) {
            note("cache file did not exist, creating it");
            read_from_cache = false;
        } else if (size != size_expected*sizeof(float)) {
            warning("cache file is corrupted or invalid, will overwrite it");
            read_from_cache = false;
        }

        if (read_from_cache) {
            cache.cache_file.seekg(0, std::ios_base::beg);
        }
    }
}

struct file_wrapper {
    std::ifstream in;
    bool doswap = false;

    explicit file_wrapper(std::string filename) : in(filename, std::ios::binary) {
        in.exceptions(in.failbit);
    }

    static void swap_endian(char& t) {}

    template<typename T>
    static void swap_endian(T& t) {
        static_assert(std::is_fundamental<T>::value, "cannot swap endian of complex type");

        union {
            T u;
            unsigned char u8[sizeof(T)];
        } source, dest;

        source.u = t;

        for (size_t k : range(sizeof(T))) {
            dest.u8[k] = source.u8[sizeof(T)-k-1];
        }

        t = dest.u;
    }

    template<std::size_t D, typename T>
    static void swap_endian(vec<D,char>& v) {}

    template<std::size_t D, typename T>
    static void swap_endian(vec<D,T>& v) {
        for (auto& val : v) {
            swap_endian(val);
        }
    }

    template<typename T>
    void read(T& val) {
        in.read(reinterpret_cast<char*>(&val), sizeof(T));

        if (doswap) {
            swap_endian(val);
        }
    }

    template<std::size_t D, typename T>
    void read(vec<D,T>& val) {
        in.read(reinterpret_cast<char*>(val.data.data()), sizeof(T)*val.size());

        if (doswap) {
            swap_endian(val);
        }
    }

    template<typename T>
    void read(T* val, uint_t n) {
        in.read(reinterpret_cast<char*>(val), sizeof(T)*n);

        if (doswap) {
            for (uint_t i : range(n)) {
                swap_endian(val[i]);
            }
        }
    }

    template<typename T>
    void seekg(T i) {
        in.seekg(i);
    }

    template<typename T, typename U>
    void seekg(T i, U u) {
        in.seekg(i, u);
    }
};

struct galaxev_ised {
    vec1f age, sfr, mass;
    vec1f lambda;
    vec2f fluxes;

private :
    vec2f extras;

public :
    bool read(std::string filename) {
        file_wrapper lib(filename);
        if (!lib.in.is_open()) {
            error("could not read library file '", filename, "'");
            return false;
        }

        try {
            // The file might have been written with a different endianess...
            // As in FAST, we try to read the number of time steps and see if
            // it makes sense, if not we switch endianess.

            {
                // Ignore the first four bytes (FORTRAN convention)
                lib.seekg(4);

                std::int64_t ntime = 0;
                lib.read(ntime);

                // Check if the number of steps makes sense
                lib.doswap = ntime < 0 || ntime > 10000;
                if (lib.doswap) {
                    // It doesn't, try again swapping the bytes
                    lib.seekg(4);
                    lib.read(ntime);
                }

                // Read time steps
                age.resize(ntime);
                lib.read(age);
            }

            // Read through info section (variable total size)
            // Get the number of extras data, in passing
            {
                // Skip IMF boundaries
                lib.seekg(2*4, std::ios::cur);
                // Skip IMF segments
                std::uint64_t imf_seg = 0;
                lib.read(imf_seg);
                lib.seekg(6*imf_seg*4, std::ios::cur);
                // Skip some more stuff
                lib.seekg(3, std::ios::cur);
                char info;
                lib.read(info);
                extras.resize(info == 0 ? 12 : 10, age.size());
                // Skip the end of the info section (fixed size)
                lib.seekg(1 + 5*4 + 80 + 4*4 + 80 + 80 + 2 + 2 + 3*4, std::ios::cur);
            }

            // Read wavelength grid
            {
                std::uint64_t nwave = 0;
                lib.read(nwave);
                lambda.resize(nwave);
                lib.read(lambda);
            }

            // Read fluxes
            {
                fluxes.resize(age.size(), lambda.size());
                for (uint_t i : range(age)) {
                    // Discard extra data
                    lib.seekg(2*4, std::ios::cur);

                    // Read data
                    std::uint64_t nlam = 0;
                    lib.read(nlam);
                    if (nlam > lambda.size()) {
                        error("invalid library file: too many wavelength values at time step id=", i);
                        return false;
                    }

                    lib.read(&fluxes(i,0), nlam);

                    // Discard extra data
                    std::uint64_t nspec = 0;
                    lib.read(nspec);
                    lib.seekg(nspec*4, std::ios::cur);
                }
            }

            // Read extras
            for (uint_t i : range(extras.dims[0])) {
                // Discard extra data
                lib.seekg(2*4, std::ios::cur);

                // Read data
                std::uint64_t ntime = 0;
                lib.read(ntime);
                if (ntime > extras.dims[1]) {
                    error("invalid library file: too many time steps for extra data id=", i);
                    return false;
                }

                lib.read(&extras(i,0), ntime);
            }
        } catch (std::ios_base::failure&) {
            error("could not read data in library file '", filename, "'");
            error("the file is probably corrupted, try re-downloading it");
            return false;
        } catch (...) {
            throw;
        }

        mass = extras(1,_);
        sfr = extras(2,_);

        return true;
    }
};

namespace dust {
    auto calzetti2000 = vectorize_lambda([](double l) {
        // http://adsabs.harvard.edu/abs/2000ApJ...533..682C

        const double iRv = 1.0/4.05;

        l *= 1e-4; // Angstrom to um
        if (l <= 0.63) {
            l = (2.659*iRv)*(-2.156 + 1.509/l - 0.198*pow(l, -2) + 0.011*pow(l, -3)) + 1.0;
        } else {
            l = (2.659*iRv)*(-1.857 + 1.040/l) + 1.0;
        }

        return l;
    });

    auto milky_way = vectorize_lambda([](double l) {
        // Reference?

        const double iRv = 1.0/3.1;

        l = 1e-4/l; // Angstrom to 1/um
        if (l <= 1.1) {
            l = (0.574 - 0.527*iRv)*pow(l, 1.61);
        } else if (l <= 3.3) {
            l -= 1.82;
            l = 1.0 + (0.17699 + 1.41338*iRv)*l - (0.50447 - 2.28305*iRv)*pow(l,2) -
                (0.02427 - 1.07233*iRv)*pow(l,3) + (0.72085 - 5.38434*iRv)*pow(l,4) +
                (0.01979 - 0.62251*iRv)*pow(l,5) - (0.77530 - 5.3026*iRv)*pow(l,6) +
                (0.32999 - 2.09002*iRv)*pow(l,7);
        } else if (l <= 8.0) {
            l = 1.752 - 3.09*iRv - (0.316 - 1.825)*l - 0.104/(pow(l - 4.67, 2) + 0.341) +
                1.206*iRv/(pow(l - 4.62, 2) + 0.263) + (l <= 5.9 ? 0 :
                    -0.04473*pow(l - 5.9, 2) - 0.009779*pow(l - 5.9, 3) +
                    (0.2130*pow(l - 5.9, 2) + 0.1207*pow(l - 5.9, 3))*iRv
                );
        } else {
            l = -1.073 + 13.67*iRv - (0.628 - 4.257*iRv)*(l - 8.0) +
                (0.137 - 0.42*iRv)*pow(l - 8.0, 2) + 0.374*iRv*pow(l - 8.0, 3);
        }

        return l;
    });

    auto noll2009 = vectorize_lambda([](double l, double eb, double delta) {
        // http://adsabs.harvard.edu/abs/2009A%26A...507.1793N

        const double iRv = 1.0/4.05;
        const double width2 = pow(350.0, 2);
        const double clam2 = pow(2175.0, 2);

        double l2 = pow(l, 2);
        return (calzetti2000(l) + iRv*eb*l2*width2/((l2 - clam2) + l2*width2))*pow(l/5500.0, delta);
    });
}

namespace igm {
    vec1d madau1995(vec1d lam, double z) {
        // http://adsabs.harvard.edu/abs/1995ApJ...441...18M
        // TODO: check this implementation someday, I suspect this is wrong
        // (taken directly from FAST)

        double da; {
            double l0 = 1050.0*(1.0 + z);
            double l1 = 1170.0*(1.0 + z);
            uint_t nstep = 100;
            vec1d tl = rgen(l0, l1, nstep);
            vec1d ptau = exp(-3.6e-3*pow(tl/1216.0, 3.46));
            da = total(ptau)*(l1-l0)/nstep/(120.0*(1.0 + z));
        }

        double db; {
            double l0 = 920.0*(1.0 + z);
            double l1 = 1015.0*(1.0 + z);
            uint_t nstep = 100;
            vec1d tl = rgen(l0, l1, nstep);
            vec1d ptau = exp(-1.7e-3*pow(tl/1026.0, 3.46) - 1.2e-3*pow(tl/972.5, 3.46) -
                9.3e-4*pow(tl/950.0, 3.46));
            db = total(ptau)*(l1-l0)/nstep/(95.0*(1.0 + z));
        }

        for (auto& l : lam) {
            if (l < 912) {
                l = 0.0;
            } else if (l < 1026) {
                l = db;
            } else if (l < 1216) {
                l = da;
            } else {
                l = 1.0;
            }
        }

        return lam;
    }
}

bool gridder_t::build_and_send(fitter_t& fitter) {
    model_t model;
    model.flux.resize(input.lambda.size());

    if (read_from_cache) {
        for (uint_t im : range(output.metal))
        for (uint_t it : range(output.tau))
        for (uint_t ia : range(output.age))
        for (uint_t id : range(output.av))
        for (uint_t iz : range(output.z)) {
            if (cache.read_model(model)) {
                // Send to fitter
                model.im = im; model.it = it; model.ia = ia; model.id = id; model.iz = iz;
                fitter.fit(model);
            } else {
                error("could not read data from cache file");
                error("the cache is probably corrupted, please remove it and try again");
                return false;
            }
        }
    } else {
        galaxev_ised ised;

        // Pre-compute distances
        vec1d dconv = 3.9080516e+13/(4.0*dpi*(1.0+output.z)*
            sqr(astro::lumdist(output.z, opts.cosmo)));

        for (uint_t im : range(output.metal))
        for (uint_t it : range(output.tau)) {
            model.im = im; model.it = it;

            // Load SSP in galaxev ised format
            std::string filename = opts.library_dir+"ised_"+opts.sfh+"."+opts.resolution+"/"+
                opts.library+"_"+opts.resolution+"_"+opts.imf+
                "_z"+replace(strn(output.metal[im]), ".", "")+"_ltau"+strn(output.tau[it])+".ised";

            if (!ised.read(filename)) {
                return false;
            }

            // Make sure input is correct
            phypp_check(is_sorted(ised.age), "galaxev age array is not sorted: ", ised.age);

            // Pre-compute dust law
            vec1d dust_law(ised.lambda.size());
            if (opts.dust_law == "calzetti") {
                dust_law = dust::calzetti2000(ised.lambda);
            } else if (opts.dust_law == "mw") {
                dust_law = dust::milky_way(ised.lambda);
            } else if (opts.dust_law == "noll") {
                dust_law = dust::noll2009(ised.lambda, opts.dust_noll_eb, opts.dust_noll_delta);
            } else if (opts.dust_law == "kc") {
                dust_law = dust::noll2009(ised.lambda, 1.0, -0.1);
            }

            // Pre-compute IGM absorption
            vec2d igm_abs(output.z.size(), ised.lambda.size());
            for (uint_t iz : range(output.z)) {
                igm_abs(iz,_) = igm::madau1995(ised.lambda, output.z[iz]);
            }

            for (uint_t ia : range(output.age)) {
                model.ia = ia;

                // Interpolate the galaxev grid at the requested age
                vec1f tpl_flux;
                double nage = e10(output.age[ia]);
                auto p = bounds(nage, ised.age);
                if (p[1] == npos) {
                    if (nage > ised.age[p[0]]) {
                        error("requested age is larger than allowed by the template library (",
                            output.age[ia], " vs. ", log10(ised.age[p[0]]), ")");
                        return false;
                    }

                    tpl_flux = ised.fluxes(p[0],_);
                    model.sfr = ised.sfr[p[0]];
                    model.mass = ised.mass[p[0]];
                } else {
                    double x = (output.age[ia] - log10(ised.age[p[0]]))/
                        (log10(ised.age[p[1]] - ised.age[p[0]]));

                    tpl_flux = ised.fluxes(p[0],_)*(1.0 - x) + ised.fluxes(p[1],_)*x;
                    model.sfr = ised.sfr[p[0]]*(1.0 - x) + ised.sfr[p[1]]*x;
                    model.mass = ised.mass[p[0]]*(1.0 - x) + ised.mass[p[1]]*x;
                }

                for (uint_t id : range(output.av)) {
                    model.id = id;

                    // Apply dust reddening
                    vec1f tpl_att_flux = tpl_flux;
                    if (output.av[id] > 0) {
                        for (uint_t il : range(tpl_att_flux)) {
                            tpl_att_flux.safe[il] *= e10(-0.4*output.av[id]*dust_law.safe[il]);
                        }
                    }

                    for (uint_t iz : range(output.z)) {
                        model.iz = iz;
                        vec1f tpl_att_z_lam = ised.lambda;
                        vec1f tpl_att_z_flux = tpl_att_flux;

                        for (uint_t il : range(tpl_att_z_flux)) {
                            // Apply IGM absorption & redshift
                            tpl_att_z_flux.safe[il] *= dconv[iz]*igm_abs.safe(iz,il);
                            tpl_att_z_lam.safe[il] *= (1.0 + output.z[iz]);
                        }

                        // Integrate
                        for (uint_t il : range(input.lambda)) {
                            model.flux[il] = astro::sed2flux(
                                input.filters[il].wl, input.filters[il].tr,
                                tpl_att_z_lam, tpl_att_z_flux
                            );
                        }

                        // Send to fitter
                        fitter.fit(model);
                        // Cache
                        cache.write_model(model);
                    }
                }
            }
        }
    }

    return true;
}
