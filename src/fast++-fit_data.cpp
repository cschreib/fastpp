#include "fast++.hpp"

struct grid_t {
    std::string cache;
    vec1f z, metal, av, age, tau;

    grid_t(const options_t& opts, const input_state_t& input, grid_t& grid);

    bool build(const options_t& opts, const input_state_t& input, grid_t& grid, uint_t iz);
};

grid_t::grid_t(const options_t& opts, const input_state_t& input, grid_t& grid) {
    // First build a new array from the provided parameters
    if (opts.z_step == 0.0 || abs(opts.z_max - opts.z_min) < opts.z_step) {
        // A single redshift
        grid.z = {opts.z_min};
    } else {
        if (opts.z_step_type == 0) {
            // "dz = cte" grid
            grid.z = rgen_step(opts.z_min, opts.z_max, opts.z_step);
        } else {
            // "dz ~ (1+z)" grid
            grid.z.push_back(opts.z_min);
            while (grid.z.back() < opts.z_max) {
                grid.z.push_back(grid.z.back() + opts.z_step*(1+grid.z.back()));
            }
        }
    }

    // Now compare this against the grid generated by the zspec/zphot provided by the user
    // In other words, if we have more galaxies to fit than the size of the above grid,
    // we use the individual zspec/zphot as the grid.

    // First compile valid zphot & zspecs
    vec1f cz = input.zspec;

    if (!input.zphot.empty()) {
        vec1u idzp = where(!is_finite(cz));
        cz[idzp] = input.zphot[idzp];
    }

    // ... and only keep valid and unique values
    cz = cz[where(is_finite(cz))];
    cz = cz[uniq(cz, sort(cz))];

    if (grid.z.size() < cz.size()) {
        grid.z = cz;
    }

    // Grid the rest of the parameter space
    grid.metal = opts.metal;
    grid.av = rgen_step(opts.a_v_min, opts.a_v_max, opts.a_v_step);
    grid.age = rgen_step(opts.log_age_min, opts.log_age_max, opts.log_age_step);
    grid.tau = rgen_step(opts.log_tau_min, opts.log_tau_max, opts.log_tau_step);

    if (opts.verbose) {
        note("fitting a grid of ", grid.z.size()*grid.av.size()*grid.age.size()*grid.tau.size(),
            " templates (nz=", grid.z.size(), ",ntau=", grid.tau.size(), ",nage=", grid.age.size(),
            ",nmetal=", grid.metal.size(), ",nav=", grid.av.size(), ")");
    }

    // Base library properties
    std::string cache_file = opts.library+"_"+opts.resolution+"_"+opts.imf+"_"+opts.sfh+"_"+opts.dust_law+"_";
    // Grid parameters
    cache_file += hash(grid.z, grid.metal, grid.av, grid.age, grid.tau, input.lambda)+".grid";

    if (opts.verbose) {
        note("using cache file ", cache_file);
    }

    // Open grid file, see what's in there but don't read yet

}

bool grid_t::build_redshift(const options_t& opts, const input_state_t& input,
    grid_t& grid, uint_t iz) {

    return true;
}

bool fit_redshift(const options_t& opts, const input_state_t& input, const grid_t& grid,
    uint_t iz, output_t& output) {

    return true;
}

bool fit_data(const options_t& opts, const input_state_t& input, output_state_t& output) {
    // Initialize the grid
    grid_t grid(opts, input, grid);

    // Now fit each redshift
    for (uint_t iz : range(grid.z)) {
        // Build/read the grid for this redshift
        if (!grid.build(opts, input, grid, iz)) {
            return false;
        }

        // Do the actual fitting
        if (!fit_redshift(opts, input, grid, iz, output)) {
            return false;
        }
    }

    return true;
}
